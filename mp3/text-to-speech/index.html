<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Text-to-Speech Reader</title>
    <!-- Tailwind CSS CDN for a modern and responsive style -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
        }
        /* Hide the default file input and style the label */
        .custom-file-input {
            display: none;
        }
        .custom-file-label {
            cursor: pointer;
        }
        .custom-file-label:hover {
            background-color: #d1d5db;
        }
    </style>
    <!-- Include pdf.js library for PDF file processing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-VY5G7GWSPR"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){
            dataLayer.push(arguments);
        }
        gtag('js', new Date());

        gtag('config', 'G-VY5G7GWSPR');
    </script>
                                       
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2334449220276386" crossorigin="anonymous"></script>
                                               
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4">

    <div class="bg-white p-6 rounded-2xl shadow-xl max-w-sm w-full">
        <br/>
        <ins class="adsbygoogle"
            style="display:block"
            data-ad-format="fluid"
            data-ad-layout-key="-gc+4r+1p-d0+h0"
            data-ad-client="ca-pub-2334449220276386"
            data-ad-slot="6758976353">
        </ins>
        <script>
            (adsbygoogle = window.adsbygoogle || []).push({});
        </script>                                                                                                    
        <br/>

        <h1 class="text-2xl font-bold text-gray-800 text-center mb-6">Text-to-Speech Reader</h1>
        
        <!-- Textarea for pasting content -->
        <textarea id="articleText" rows="8" placeholder="Paste your text here..."
                  class="w-full p-3 border border-gray-300 rounded-xl focus:outline-none focus:ring-2 focus:ring-blue-500 transition-colors duration-200 resize-y"></textarea>
        
        <!-- Character counter and limit message -->
        <div class="text-right text-xs text-gray-500 mt-1 mb-4">
            Characters: <span id="charCount">0</span> / 4000
            <p id="charLimitMessage" class="text-red-500 hidden mt-1">Text is too long for stable playback. Please shorten it.</p>
        </div>

        <!-- File upload and voice selection options -->
        <div class="flex flex-col justify-between items-center mb-6 space-y-4">
            
            <!-- Upload text/pdf file -->
            <div class="w-full">
                <input type="file" id="fileInput" class="custom-file-input" accept=".txt,.pdf">
                <label for="fileInput" class="custom-file-label flex items-center justify-center px-4 py-2 bg-gray-200 text-gray-700 font-semibold rounded-xl transition-all duration-200 hover:bg-gray-300 text-sm">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M4 4a2 2 0 012-2h4.586A2 2 0 0112 2.586L15.414 6A2 2 0 0116 7.414V16a2 2 0 01-2 2H6a2 2 0 01-2-2V4zm2 2h4v2H6V6zm0 4h8v2H6v-2zm0 4h8v2H6v-2z" clip-rule="evenodd" />
                    </svg>
                    <span>Upload .txt or .pdf file</span>
                </label>
            </div>

            <!-- Voice selector -->
            <div class="w-full">
                <select id="voiceSelect" class="w-full px-4 py-2 border border-gray-300 rounded-xl focus:outline-none focus:ring-2 focus:ring-blue-500 transition-colors duration-200 text-sm">
                    <option value="" disabled selected>Select a voice</option>
                </select>
            </div>
        </div>
        
        <!-- Trim text button (conditionally visible) -->
        <button id="trimBtn" class="hidden w-full mb-3 bg-gray-500 text-white font-semibold py-2 px-6 rounded-xl shadow-md hover:bg-gray-600 transition-colors duration-200 text-sm">
            Trim Text to 4000 Chars
        </button>

        <!-- Playback control buttons -->
        <div class="flex flex-col space-y-3">
            <button id="playBtn" class="bg-blue-600 text-white font-semibold py-2 px-6 rounded-xl shadow-md hover:bg-blue-700 transition-colors duration-200 text-sm">
                Play
            </button>
            <div class="flex justify-between space-x-3">
                <button id="pauseBtn" class="w-1/2 bg-yellow-500 text-white font-semibold py-2 px-6 rounded-xl shadow-md hover:bg-yellow-600 transition-colors duration-200 text-sm">
                    Pause
                </button>
                <button id="stopBtn" class="w-1/2 bg-red-500 text-white font-semibold py-2 px-6 rounded-xl shadow-md hover:bg-red-600 transition-colors duration-200 text-sm">
                    Stop
                </button>
            </div>
        </div>
        
        <!-- Status messages -->
        <div id="messageBox" class="mt-4 text-center text-gray-600 text-xs"></div>

        <br/>
        <ins class="adsbygoogle"
            style="display:block"
            data-ad-client="ca-pub-2334449220276386"
            data-ad-slot="6625994850"
            data-ad-format="auto"
            data-full-width-responsive="true"></ins>
        <script>
            (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
        <br/>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // References to DOM elements
            const articleText = document.getElementById('articleText');
            const fileInput = document.getElementById('fileInput');
            const voiceSelect = document.getElementById('voiceSelect');
            const playBtn = document.getElementById('playBtn');
            const pauseBtn = document.getElementById('pauseBtn');
            const stopBtn = document.getElementById('stopBtn');
            const messageBox = document.getElementById('messageBox');
            const charCount = document.getElementById('charCount');
            const charLimitMessage = document.getElementById('charLimitMessage');
            const trimBtn = document.getElementById('trimBtn');
            
            // Define a max character limit to prevent browser issues
            const MAX_CHAR_LIMIT = 4000;

            // Check if the browser supports the SpeechSynthesis API
            if ('speechSynthesis' in window) {
                let speech = new SpeechSynthesisUtterance();
                let voices = [];

                // Function to update the character counter
                function updateCharCounter() {
                    const length = articleText.value.length;
                    charCount.textContent = length;
                    if (length > MAX_CHAR_LIMIT) {
                        charLimitMessage.classList.remove('hidden');
                        playBtn.disabled = true;
                        playBtn.classList.add('opacity-50', 'cursor-not-allowed');
                        trimBtn.classList.remove('hidden');
                    } else {
                        charLimitMessage.classList.add('hidden');
                        playBtn.disabled = false;
                        playBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                        trimBtn.classList.add('hidden');
                    }
                }

                // Function to fill the voice selector and restore last selection
                function populateVoiceList() {
                    voices = window.speechSynthesis.getVoices().sort((a, b) => {
                        const aname = a.name.toUpperCase();
                        const bname = b.name.toUpperCase();
                        if (aname < bname) return -1;
                        if (aname > bname) return 1;
                        return 0;
                    });
                    voiceSelect.innerHTML = '<option value="" disabled selected>Select a voice</option>';
                    voices.forEach(voice => {
                        const option = document.createElement('option');
                        option.textContent = `${voice.name} (${voice.lang})`;
                        option.setAttribute('data-lang', voice.lang);
                        option.setAttribute('data-name', voice.name);
                        voiceSelect.appendChild(option);
                    });

                    // Restore the last selected voice from localStorage
                    const lastVoiceName = localStorage.getItem('lastVoiceName');
                    if (lastVoiceName) {
                        const savedVoiceOption = [...voiceSelect.options].find(option => option.dataset.name === lastVoiceName);
                        if (savedVoiceOption) {
                            savedVoiceOption.selected = true;
                        }
                    }
                }
                
                // Cargar la lista de voces solo cuando estÃ© disponible
                if (window.speechSynthesis.getVoices().length > 0) {
                    populateVoiceList();
                } else {
                    window.speechSynthesis.onvoiceschanged = populateVoiceList;
                }

                // Save the selected voice to localStorage
                voiceSelect.addEventListener('change', () => {
                    const selectedVoiceName = voiceSelect.selectedOptions[0].getAttribute('data-name');
                    localStorage.setItem('lastVoiceName', selectedVoiceName);
                });

                // Add an input event listener to the textarea for character counting
                articleText.addEventListener('input', updateCharCounter);
                updateCharCounter(); // Initial count

                // Load text from a file
                fileInput.addEventListener('change', async (e) => {
                    const file = e.target.files[0];
                    if (!file) return;

                    messageBox.textContent = 'Loading file...';
                    articleText.value = '';

                    if (file.type === 'text/plain') {
                        const reader = new FileReader();
                        reader.onload = (event) => {
                            articleText.value = event.target.result;
                            messageBox.textContent = '.txt file loaded successfully.';
                            updateCharCounter();
                        };
                        reader.onerror = () => {
                            messageBox.textContent = 'Error reading the file.';
                        };
                        reader.readAsText(file);
                    } else if (file.type === 'application/pdf') {
                        try {
                            const arrayBuffer = await file.arrayBuffer();
                            
                            const pdfjsLib = window['pdfjs-dist/build/pdf'];
                            pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js`;

                            const pdfDoc = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                            let textContent = '';
                            
                            for (let i = 1; i <= pdfDoc.numPages; i++) {
                                const page = await pdfDoc.getPage(i);
                                const text = await page.getTextContent();
                                textContent += text.items.map(item => item.str).join(' ') + '\n\n';
                            }
                            
                            articleText.value = textContent;
                            messageBox.textContent = '.pdf file loaded successfully.';
                            updateCharCounter();
                        } catch (error) {
                            messageBox.textContent = 'Error processing the PDF file.';
                            console.error('Error processing PDF:', error);
                        }
                    } else {
                        messageBox.textContent = 'Unsupported file format. Please upload a .txt or .pdf file.';
                    }
                });
                
                // Event listener for the new trim button
                trimBtn.addEventListener('click', () => {
                    articleText.value = articleText.value.substring(0, MAX_CHAR_LIMIT);
                    updateCharCounter();
                    messageBox.textContent = 'Text trimmed to 4000 characters.';
                });

                // Play event listener
                playBtn.addEventListener('click', () => {
                    if (window.speechSynthesis.speaking && window.speechSynthesis.paused) {
                        // If playback is paused, resume it.
                        window.speechSynthesis.resume();
                        messageBox.textContent = 'Resuming playback...';
                    } else if (articleText.value.trim() !== '') {
                        // If not speaking, start a new playback.
                        window.speechSynthesis.cancel(); // Cancel any previous utterance to start fresh.
                        speech.text = articleText.value;
                        const selectedOption = voiceSelect.selectedOptions[0];
                        
                        if (selectedOption) {
                            const selectedVoiceName = selectedOption.getAttribute('data-name');
                            const selectedVoiceLang = selectedOption.getAttribute('data-lang');
                            
                            const selectedVoice = voices.find(v => v.name === selectedVoiceName);
                            
                            if (selectedVoice) {
                                speech.voice = selectedVoice;
                                speech.lang = selectedVoiceLang;
                                window.speechSynthesis.speak(speech);
                                messageBox.textContent = 'Playing...';
                            } else {
                                messageBox.textContent = 'Please select a valid voice.';
                            }
                        } else {
                            messageBox.textContent = 'Please select a voice.';
                        }
                    } else {
                        messageBox.textContent = 'Please enter some text to play.';
                    }
                });

                // Pause event listener
                pauseBtn.addEventListener('click', () => {
                    if (window.speechSynthesis.speaking) {
                        window.speechSynthesis.cancel();
                        messageBox.textContent = 'Playback paused.';
                    } else {
                        messageBox.textContent = 'Nothing is currently playing to pause.';
                    }
                });

                // Stop event listener
                stopBtn.addEventListener('click', () => {
                    window.speechSynthesis.cancel();
                    messageBox.textContent = 'Playback stopped.';
                });

                // Event when playback ends
                speech.onend = () => {
                    messageBox.textContent = 'Playback finished.';
                };

                // Error event
                speech.onerror = (event) => {
                    messageBox.textContent = 'Error in speech synthesis: ' + event.error;
                };

            } else {
                // Message if the API is not available
                messageBox.textContent = 'Sorry, your browser does not support the Text-to-Speech API.';
                [playBtn, pauseBtn, stopBtn, fileInput, voiceSelect].forEach(el => el.disabled = true);
            }
        });
        window.onbeforeunload = () => {
            if ('speechSynthesis' in window)
            {
                window.speechSynthesis.cancel();
            }
        };
    </script>
</bdy>
</html>
